Technical Impression:

Even before starting the project, as I read the homework document, I had some questions such as how to create a simple protocol on our own to communicate between client and server. It was not clear if we must create it using XML or some other protocols. In regard to the unrequested datagram packets, as it is a simple interaction of client and server, I found it difficult to understand how to test this kind of cases. As a result, help from TA was required to clarify some of the requirements.

After starting the assignment, I was unsure which of the Tanenbaumâ€™s client-server organization to follow. I first had checks of client input on client side, but the code was getting redundant as the same check was applied on server side. I eventually ended up using the 2nd organization, only the user interface on client side and the processing (including all checks) and data layer on the server side. Since the clients and the servers have some methods in common, I decided to add AbstractClient and AbstractServer that each client and server can extend. The differences in TCP and UDP clients and servers is the way connection is established (in TCP), Datagrams created (in UDP) and how the data is sent in both protocols. All the backend APIs are written in their respective Abstract Classes. I even created separate log files of each application that store the logs present in the terminal. After running the applications locally, major issues occurred during the creation of Dockerfile and bash files to run docker images. Since it was a new concept, it took some time and tutorials to understand the importance of docker and how to use it. The resources provided to understand docker including sample Dockerfile and scripts were highly useful to create and modify my own Dockerfile the way I want it to run.

In summary, this project required to make design choices, and after the project was completed, I was satisfied with the way I implemented the requirements and how the applications work.
